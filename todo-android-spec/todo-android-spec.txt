Ringdown Android Client UX Specification
Date: 2025-10-18

1. Purpose
- Deliver a personal, data-only Android interface for the existing Ringdown backend.
- Prioritise hands-free voice use while enabling manual text chat as an alternate mode.
- Maintain feature parity with the current Twilio voice experience (agents, tools, prompts) without expanding scope beyond flows discussed here.

2. Core Assumptions
- Single trusted user per phone and per bot, with only a handful of users total, but multiple preconfigured personas exist in backend config (mirrors caller-ID agents today).
- The Android client talks directly to the current FastAPI backend (Twilio ConversationRelay-compatible websocket and HTTP endpoints) with no additional middle tier.
- Credentials are baked into the app build; no login or user-managed auth inside the UI.
- Bluetooth audio accessories are commonly in use; the user may be driving and unable to interact with the screen once a session starts.

3. Application States
- Pending device approval (first run on an unregistered device).
- Idle main screen (no active voice session).
- Active voice session.
- Chat session (voice suspended).
- Automatic reconnection loop after an unexpected disconnect.

4. Launch and Device Registration Flow
→ See mockup: mockup-1-pending-approval.html

- On first launch, the app generates or retrieves a stable device identifier and calls the backend registration endpoint.
- If the backend recognises the device (enabled in config.yaml), the app proceeds directly into the standard voice flow described below.
- If the backend does not recognize it, it auto-adds the device as disabled, and the app receives a pending response. Behaviour:
  - Show a blocking modal dialog that explains approval is required.
  - Provide a single primary action labeled Check again. Each tap re-issues the registration check.
  - The dialog remains visible between checks. When the backend flips the entry to enabled, the next check immediately dismisses the dialog and transitions into voice call startup without returning to the idle screen.
  - No other navigation or features are available while pending.

5. Permissions Handling
→ See mockup: mockup-7-permission-denied.html

- Whenever the app attempts to start or resume a voice session (including automatic launch connect, manual reconnect, or background auto-retry), it first verifies RECORD_AUDIO and any required Bluetooth permissions.
- If permissions are missing, surface the system permission sheet immediately.
- If the user denies, treat it exactly like a user-initiated hangup: stop trying to connect, display the idle main screen, and surface inline text under the Reconnect button noting Microphone permission required. The next attempt to connect re-triggers the sheet.

6. Idle Main Screen
→ See mockup: mockup-2-idle-main.html

- Visible only when no voice call and no pending approval dialog.
- Layout: app background + two primary buttons stacked vertically or center-aligned: Reconnect (or Connect on first load) and Open Chat. No additional text, status, or chrome.
- Motion: replicate button press states, hover/pressed elevation changes, and any idle-to-pending transitions shown in the mockup. Use your best judgment if animation timings are unspecified.
- Tapping Reconnect initiates the voice session flow described below.
- Tapping Open Chat switches to the chat session 3as described in Section 8.
- **Implementation note:** Mirror the layout, spacing, typography, and button treatments in the referenced mockup exactly. Treat the HTML mockup as source of truth for paddings, corner radii, and type ramp.

7. Voice Session Experience
→ See mockups: mockup-3-voice-active.html (active session), mockup-4-voice-reconnecting.html (reconnecting state), mockup-8-background-notification.html (backgrounded)

- Entry: Upon successful permissions and registration, the app auto-connects to the backend call websocket using the device's mapped agent. No user confirmation.
- Screen: The voice UI displays only a large, circular, Hang Up button centered vertically and horizontally that takes up 50% of the screen width.
- Audio routing: Immediately request Bluetooth SCO routing and stay locked to it while available. If Bluetooth disconnects, fall back to device speakerphone. No manual route picker in UI.
- Backgrounding: If the user locks the device, switches apps, or the UI otherwise loses foreground focus, keep the voice session active. Show a persistent system notification (ongoing call category) with:
  - Title indicating active connection (e.g., Danbot call in progress).
  - Single action Hang Up, which terminates the session and returns the state to the idle main screen when the user reopens the app.
- Unexpected disconnects (network, backend error):
  - Immediately play the local reconnecting audio clip on a loop with a delay between repeats. Cancel it when it is reconnected.
  - Surface a short banner at the bottom with the best possible user-facing explanation for the hangup (e.g., Network unavailable, AI timeout).
  - The app initiates up to 1 minute of reconnect attempts with a backoff suited for real-time use (e.g., 3–5 seconds); no user intervention required.
  - The Hang Up button remains available to abort the loop. When pressed, retries stop and the app returns to the idle main screen.
- Successful reconnect after a failure removes banners and resumes normal audio.
- **Implementation note:** All voice session screens must match mockup visual details (button proportions, banner placement, notification copy) unless explicitly deferred in a later phase. Honor any motion cues in the references (e.g., reconnect banner slide-up, hang-up button press feedback) and log gaps when specs are missing.

8. Mode Switching Between Voice and Chat
- Hang Up button (during active call) ends the current session and transitions to the idle main screen.
- From the idle main screen, tapping Open Chat immediately enters chat mode.
- Within chat mode, a persistent control labeled Voice sits in the header. Activating it closes chat and starts the voice connection flow (respecting permissions) without a separate confirmation.
- The voice mode has a timeout where it reconnects to the same session by default if it's been less than 5 min. Use of the chat client is counted towards this timeout.
- The chat system does not have a timeout; it always picks up the previous system.

9. Chat Session Experience
→ See mockups: mockup-5-chat-session.html (chat interface), mockup-6-chat-tool-expanded.html (expanded tool view)

- Layout: full-height transcript view with newest messages at bottom, streaming updates as chunks arrive from the backend.
- Content stream: includes assistant turns, user turns (captured via chat or prior voice transcription), system notifications, and tool activity markers sourced from the existing backend message log.
- Tool visibility: each tool invocation renders as a collapsed pill (e.g., Tool: TavilySearch). Tapping expands an in-place panel showing a user-friendly version of the request/response payload and any structured output the backend surfaces today. Collapse toggles on second tap anywhere within the section.
- Thinking tokens emitted by the backend render as collapsible blocks similar to tool pills.
- All pills stack from left to right in the same line, wrapping as needed (not one per line).
- Composer: single-line text input with Send icon. There is an attachment button which opens the device attachment dialogue; it can support up to 9 attachments.
- There is a 'reset' button that wipes the conversation and creates a new one.
- Model selector: header-level dropdown populated from the backend’s permitted models, ordered by most recently used (MRU first, updating whenever the user switches). Selection does not use the change-llm tool but instead innvokes the switch immediately and reflects in subsequent turns. The selector is only present in chat mode.

10. Persistent Conversation Handling
- The app relies on the backend’s existing message persistence (SQLite state, continue_conversation flag). Voice and chat modes share the same conversation state; ending voice or switching modes never purges history unless the reset tool is invoked via the assistant.
- The first voice turn after a reset or new session uses the configured welcome greeting defined for the agent associated with the device.

11. Device-to-Agent Mapping
- Each device is mapped to an agent entry created in config.yaml when it first connects to the backend. The backend is responsible for adding a fully populated entry (device id, friendly label, agent name, enabled flag, and any other fields it requires) when a new device connects, with enabled defaulting to false.
- The device id must be stable so repeated connections do not generate multiple config entries.
- The key security mechanism is that no client can do anything except trigger its disabled addition to config.yaml without an admin modifying config.yaml by hand to enable it.
- The Android app does not edit config.yaml; it simply surfaces pending status and polls until the backend reports the device as enabled.
- When multiple agents exist for a single user (e.g., Dan, Ina, Elan), enabling the device entry determines which persona handles subsequent sessions. The app reflects whatever agent the backend returns; no in-app selector.

12. Notification Behaviour
→ See mockup: mockup-8-background-notification.html

- While connected (foreground or background), a single ongoing notification is shown with hang up action only.
- When the session ends (user hangup or backend disconnect with retries exhausted), remove the notification immediately.

13. Audio Assets
- The app bundles a reconnecting audio file (provided as an mp3 and converted as needed by the app) for when the reconnect loop starts.
- No other status tones are introduced beyond whatever the backend streams today (thinking and completion chimes already originate server-side).

14. Error Messaging Summary
- Missing permissions: idle screen note Microphone permission required until the next connect attempt.
- Pending approval: blocking dialog with device ID, Check again button, and brief copy instructions.
- Unexpected disconnect: transient reason banner plus reconnecting audio, followed by silent retries.
- Registration failure after approval (e.g., backend down): treat as unexpected disconnect with reason from backend.

15. Out of Scope for This Spec
- Any redesign of backend flows, tool surfaces, or agent prompts.
- Additional UI beyond the elements described above (no call duration, no manual audio routing, no transcripts during live voice).
- Scheduling, implementation estimates, or engineering choices (SDKs, LiveKit vs. WebRTC specifics) beyond what is already implemented server-side.

16. Implementation Plan (Agent-Owned)
- The same engineer (this agent) executes each phase sequentially, validating the build after every major change before moving forward. All repeatable work happens through bash commands that Codex CLI can execute without manual intervention beyond initial Android SDK configuration.
- Priority: get a branded-but-minimal app rendering on a physical Android phone immediately, then iterate. Use `mobile-next/mobile-mcp` to drive the device from the CLI for every on-device validation.

Phase 0 - Tooling & Project Bootstrap
- Provision Android command-line tools and required SDKs inside the Codex CLI container using a reproducible script: `bash android/scripts/setup-sdk.sh --api 35 --build-tools 35.0.0` (script will install sdkmanager components and accept licenses non-interactively).
- Initialise `android/app` with Kotlin + Jetpack Compose single-activity template via `bash android/scripts/init-project.sh` (scaffolds Gradle wrapper, module, package structure, ktlint, `.editorconfig`, and CI workflow stub).
- Verify Gradle by running `bash android/scripts/gradle.sh ./gradlew tasks` (wrapper script sets JAVA_HOME, ANDROID_HOME, and caches dependencies). Deliverable: empty activity builds and installs on emulator using `bash android/scripts/emulator-smoke.sh`.
- Connect to the tethered phone with `mobile-mcp` (from https://github.com/mobile-next/mobile-mcp) and push the initial debug build. Build the APK once via `bash android/scripts/gradle.sh ./gradlew :app:assembleDebug`, then install it with `mobile-mcp install_app --device $ANDROID_SERIAL --path android/app/app/build/outputs/apk/debug/app-debug.apk` (wake/unlock the phone first). Because DrvFS can block Gradle's cache moves for `adb`, only fall back to the shell installer if necessary: `GRADLE_USER_HOME=$HOME/.gradle-ringdown bash android/scripts/install.sh --device $ANDROID_SERIAL`. After installation, launch the UI and capture proof via `mobile-mcp run android/scripts/mobile/sanity.mcp`, which drives the pending-approval placeholder and saves a screenshot. Deliverable: minimalist Compose screen visible on the physical phone within this phase.
- Secrets & config hygiene: place runtime credentials under `android/config/.env` (backend base URL, API tokens) and signing artifacts inside `android/keys/` (e.g., `internal.keystore`, Play Developer service accounts). These paths are gitignored—check in example templates (e.g., `android/config/.env.example`) but never real secrets.

Phase 1 - Core Architecture & Registration Skeleton
- Implement base packages (`data`, `domain`, `ui`) and Dependency Injection graph (Hilt) via MCP-assisted Kotlin scaffolding commands embedded in `bash android/scripts/generate.sh`.
- Add device ID persistence and registration API client stubs with Retrofit + OkHttp. Compose idle/pending approval layouts with state machine skeleton (StateFlow + reducers).
- Declare `android.permission.INTERNET` in the manifest so Retrofit/OkHttp networking succeeds once real endpoints are enabled.
- Automated checks: `bash android/scripts/gradle.sh ./gradlew :app:assembleDebug :app:lintDebug :app:testDebugUnitTest`. Deploy to emulator for smoke via `bash android/scripts/install.sh --emulator`. Deliverable: app reaches pending dialog with stubbed backend responses.
- Extend the `mobile-mcp` automation to run the pending approval flow on-device (launch app, trigger pending dialog, capture screenshot artifact) so every iteration still validates against real hardware.
    * Current stub behaviour: `StubRegistrationInterceptor` approves on the third poll. Expect to see Attempts increment from 1 → 2 before the idle screen appears. Leave this threshold configurable when wiring real backend.
    * Device IDs are persisted via `DataStore` under `ringdown_device.preferences_pb`; treat it as opaque and use the provided repository/UseCase plumbing instead of rolling your own.
    * Hilt is now required for app startup; `RingdownApp` is registered in the manifest. Any new components should request dependencies through DI rather than manual singletons.
    * **UI fidelity:** For every Compose surface introduced in this phase, replicate the matching mockup in `todo-android-spec/` (e.g., mockup-1-pending-approval.html). Use the document measurements for spacing, typography, and component hierarchy.

Phase 2 – Backend Integration & Permission Handling
- Connect registration flow to staging backend using environment-configured base URL (`android/config/.env`) loaded by Gradle. Replace stubs with real Retrofit services and WebSocket handshake to register device.
- Source `BuildConfig.BACKEND_BASE_URL` from build-type or flavor configuration instead of a single hard-coded string so release builds target production.
- Gate the stub interceptor behind a debug-only variant or feature flag to keep production traffic on the real backend.
- Surface server-provided polling hints by plumbing `pollAfterSeconds` (or equivalent) from the Retrofit DTO through domain models and into the ViewModel retry strategy.
- Wire permission manager (Accompanist) and ensure denied permissions revert to idle with inline messaging.
- Track permission result transitions explicitly (e.g. observe status via `snapshotFlow` or keyed `LaunchedEffect`) so reconnect/error handlers run immediately after the system dialog closes.
- `.env` contract: require `STAGING_BACKEND_BASE_URL`, `PRODUCTION_BACKEND_BASE_URL`, `DEBUG_USE_REGISTRATION_STUB`, and `DEBUG_STUB_APPROVAL_THRESHOLD` (all build variants read via Gradle at configuration time). Backend URLs must include the trailing slash so Retrofit base URLs resolve correctly.
- Debug builds honour runtime overrides for the registration stub via `DebugFeatureFlags`; instrumentation switches the stub off while hijacking traffic to the local `MockWebServer`.
- Provide an instrumentation-only Hilt module (or equivalent) that overrides the Retrofit base URL with `mockWebServer.url("/")` so registration polls never escape the test harness.
- Automation: `bash android/scripts/mock-server.sh start` (spawns MockWebServer for CI), run integration tests `bash android/scripts/gradle.sh ./gradlew :app:connectedDebugAndroidTest -Pandroid.testInstrumentationRunnerArguments.class=...RegistrationSuite`, then stop mock server script.
- Instrumented tests use `HiltTestApplication` (`src/androidTest/AndroidManifest.xml`) so any new instrumentation must stay compatible with Hilt injection.
- `mock-server.sh` wraps `android/scripts/mock_server.py` so CI and local workflows get consistent behaviour (configurable port, approval threshold, and poll hint). Use the script instead of invoking the Python module directly.
- Known gap: Gradle `:app:assembleDebug` currently fails under WSL due to AAPT2 spawn helper issues (`Failed to exec spawn helper`). Run the Phase 2 automation on native Linux/macOS until the WSL environment is configured with metadata or an ext4-backed workspace so AAPT2 can launch.
- After resolving AAPT2, immediately run `bash android/scripts/gradle.sh ./gradlew :app:assembleDebug :app:lintDebug :app:testDebugUnitTest` followed by `bash android/scripts/gradle.sh ./gradlew :app:connectedDebugAndroidTest -Pandroid.testInstrumentationRunnerArguments.class=com.ringdown.registration.RegistrationSuite`.
- Deploy to USB device with `bash android/scripts/install.sh --device $ANDROID_SERIAL` (Codex CLI sets serial). Deliverable: device auto-registers and transitions to idle when backend approval flips.

Phase 3 - Voice Session MVP (Fast Track)
- Implement a WebRTC voice client that connects to an `aiortc` peer hosted inside the FastAPI service; reuse the existing WebSocket channel purely for signaling. Compose Hang Up UI, audio routing via `AudioManager` + Bluetooth SCO utilities, and start ForegroundService with persistent notification.
- Define a thin VoiceTransport interface (connect, sendAudioFrame, receiveAudioFrame, teardown) so the WebRTC stack can be swapped for LiveKit/Daily or a future transport without touching UI/domain layers.
- Add CLI automation for live call smoke test: `bash android/scripts/run-voice-smoke.sh --backend $BACKEND_URL` (script launches instrumentation that connects, streams dummy audio, asserts hang-up path).
- Run `bash android/scripts/gradle.sh ./gradlew :app:assembleDebug :app:testDebugUnitTest :app:connectedVoiceMvpAndroidTest`. Deliverable: first end-to-end voice call from emulator and USB device using only scripted commands.
- Configure the Android `.env` to point at the production HTTPS backend (the service is live). Loops at `127.0.0.1` or any other cleartext URL are not acceptable—Phase 3 validation requires hitting the real backend over TLS so the voice flow mirrors production.
- Add admin helper `python authorize_new_phone.py` to streamline device approvals: the script resolves the repo root, downloads the pending config from `gs://<project>-test-assets/config/pending/config.yaml`, shows a unified diff against the local `config.yaml`, flips all `enabled: false` phone entries to `true`, writes a timestamped backup, promotes the approved config to `gs://<project>-test-assets/config/live/config.yaml`, and deletes the pending artifact once confirmed.
- Ensure the end-to-end “promote pending phone” workflow (authorize script + backend job) runs as part of Phase 3 validation so device approvals remain deployable without manual YAML edits.
- Outstanding (Phase 3 follow-up):
  - [Completed 2025-10-20] WebRTC transport now streams live assistant audio end-to-end (microphone uplink with OpenAI transcription + aiortc downlink TTS); remaining follow-ups below carry forward.
  - Wire the new WebRTC smoke script (`android/scripts/run-voice-smoke.sh`) into CI after ensuring emulator/device `adb` visibility; at present it must be run manually against a tethered device.
  - Broaden instrumentation coverage to exercise the voice WebRTC path (connectedVoiceMvpAndroidTest) and verify audio frame exchange to guard regressions.

Phase 4 – Reconnect Loop & Audio Asset Polish
- Bundle reconnect audio asset under `android/app/app/src/main/res/raw/reconnect_loop.ogg`; script `bash android/scripts/convert-audio.sh assets/reconnect.mp3` handles conversion.
- Implement reconnect backoff scheduler, banner messaging, and ensure notification removal on completion. Extend smoke test script to toggle network via `adb shell cmd connectivity airplane-mode enable/disable` within bash automation.
- Tests: `bash android/scripts/gradle.sh ./gradlew :app:testDebugUnitTest --tests "*Reconnect*" :app:connectedDebugAndroidTest -Pandroid.testInstrumentationRunnerArguments.annotation=ReconnectSuite`.
- Outstanding (Phase 4 follow-up): wire the reconnect audio loop, banner messaging, and notification lifecycle once the transport is live so reconnect UX matches spec.

Phase 5 – Chat Mode & Shared Conversation State
- Generate chat UI (LazyColumn, attachments, reset, model selector) with Compose using MCP templates. Implement repository sharing conversation state between voice/chat with Room-backed cache and streaming updates from backend log endpoints.
- Provide CLI command `bash android/scripts/run-chat-smoke.sh --backend $BACKEND_URL --fixtures fixtures/chat/*.json` to replay log fixtures against the UI.
- Tests: `bash android/scripts/gradle.sh ./gradlew :app:testDebugUnitTest :app:connectedChatAndroidTest :app:verifyComposeSnapshots`. Deliverable: fully functional chat with tool/thinking pills and attachments cap enforcement.

Phase 6 – Hardening, Analytics, and Deployment
- Add accessibility labels, localisation hooks, Crashlytics (behind build flag), and WorkManager jobs for background reconnect resilience. Ensure CLI workflow `bash android/scripts/full-ci.sh` chains lint, unit, instrumentation, and bundle builds.
- Produce release bundle with `bash android/scripts/gradle.sh ./gradlew :app:bundleRelease` and sign via `bash android/scripts/signing.sh --keystore keys/internal.keystore`.
- For deployment, run `bash android/scripts/publish-internal.sh --track internal --artifact app/build/outputs/bundle/release/app-release.aab` (script uses Play Developer API credentials configured beforehand). Deliverable: release candidate uploaded to internal testing without manual UI steps.

Ongoing Operations
- Nightly CI job triggers `bash android/scripts/full-ci.sh` and archives emulator + device logs.
- Before each release, execute `bash android/scripts/device-soak.sh --duration 30m` to automate reconnect stress test on a tethered phone.
